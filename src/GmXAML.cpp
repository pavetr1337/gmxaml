#include "GmXAML.h"

using namespace std;

// Checkers
bool isNumeric(const std::string& value) {
    std::regex num_re("^[-+]?(\\d*\\.?\\d+)$");
    return std::regex_match(value, num_re);
}

bool isVector(const std::string& value) {
    std::regex vec_re("^Vector\\([\\d\\.\\-, ]+\\)$");
    return std::regex_match(value, vec_re);
}

bool isAngle(const std::string& value) {
    std::regex ang_re("^Angle\\([\\d\\.\\-, ]+\\)$");
    return std::regex_match(value, ang_re);
}

bool isHexColor(const std::string& value) {
    std::regex hex_re("^#([\\da-fA-F]{6}|[\\da-fA-F]{8})$");
    return std::regex_match(value, hex_re);
}

bool isBoolean(const std::string& str) {
    std::string s = str;
    std::transform(s.begin(), s.end(), s.begin(), ::tolower);
    return s == "true" || s == "false";
}

bool isViewportWidth(const std::string& val) {
    if (val.size() > 2 && val.substr(val.size() - 2) == "vw") {
        return isNumeric(val.substr(0, val.size() - 2));
    }
    return false;
}

bool isViewportHeight(const std::string& val) {
    if (val.size() > 2 && val.substr(val.size() - 2) == "vh") {
        return isNumeric(val.substr(0, val.size() - 2));
    }
    return false;
}


std::string hexToColor(const std::string& hex) {
    int r, g, b, a = 255;
    if (hex.length() == 7) {
        sscanf(hex.c_str(), "#%02x%02x%02x", &r, &g, &b);
    }
    else if (hex.length() == 9) {
        sscanf(hex.c_str(), "#%02x%02x%02x%02x", &r, &g, &b, &a);
    }
    return std::format("Color({},{},{},{})", r, g, b, a);
}

bool enable_glob = false;
std::string glob_text = "-- Required functions\n"
                        "local gxaml = {}\n"
                        "gxaml.sw = ScrW()\n"
                        "gxaml.sh = ScrH()\n"
                        "function gxaml.scrw(units)\n"
                        "   return gxaml.sw*(units/100)\n"
                        "end\n"
                        "function gxaml.scrh(units)\n"
                        "   return gxaml.sh*(units/100)\n"
                        "end\n";
std::string mark_text = "-- Generated by GmXAML (https://github.com/pavetr1337/gmxaml)\n";

std::vector<std::string> splitAndTrim(const std::string& str) {
    std::vector<std::string> result;
    std::stringstream ss(str);
    std::string item;

    while (std::getline(ss, item, ',')) {
        item.erase(0, item.find_first_not_of(" \t\n\r"));
        item.erase(item.find_last_not_of(" \t\n\r") + 1);
        result.push_back(item);
    }

    return result;
}

std::string formatSingleValue(const std::string& val) {
    if (isNumeric(val) || isVector(val) || isAngle(val)) {
        return val;
    }
    else if (isViewportWidth(val)) {
        enable_glob = true;
        return std::format("gxaml.scrw({})", val.substr(0, val.size() - 2));
    }
    else if (isViewportHeight(val)) {
        enable_glob = true;
        return std::format("gxaml.scrh({})", val.substr(0, val.size() - 2));
    }
    else if (isHexColor(val)) {
        return hexToColor(val);
    }
    else if (isBoolean(val)) {
        std::string bval = val;
        std::transform(bval.begin(), bval.end(), bval.begin(), ::tolower);
        return bval;
    }
    else {
        return std::format("'{}'", val);
    }
}

std::string formatAttr(const std::string& xclass, const std::string& name, const std::string& value) {
    std::vector<std::string> parts = splitAndTrim(value);

    if (parts.size() == 1) {
        std::string formatted = formatSingleValue(parts[0]);
        return std::format("{}:{}({})\n", xclass, name, formatted);
    }
    else {
        std::string result = xclass + ":" + name + "(";
        for (size_t i = 0; i < parts.size(); ++i) {
            result += formatSingleValue(parts[i]);
            if (i != parts.size() - 1) result += ", ";
        }
        result += ")\n";
        return result;
    }
}

std::pair<pugi::xml_document,pugi::xml_parse_result> load_xml(std::string path) {
    pugi::xml_document doc;
    std::ifstream stream(path);
    pugi::xml_parse_result res = doc.load(stream);
    return { std::move(doc), res };
}

std::vector<std::string> manual_attrs = { "Dock", "DoClick", "Paint", "x:Class" };

std::string translate_tag(const pugi::xml_node& node) {
    std::string xclass = node.attribute("x:Class").value();
    std::string tagname = node.name();

    if (xclass.empty() || tagname.empty()) {
        return "";
    }

    std::string tag_code = std::format("local {} = vgui.Create('{}'{})\n",
        node.attribute("x:Class").value(),
        node.name(),
        node.parent().name()==""
        ? std::string("")
        : std::string(", ") + node.parent().attribute("x:Class").value()
    );

    for (pugi::xml_attribute attr : node.attributes()) {
        if (std::find(manual_attrs.begin(), manual_attrs.end(), attr.name()) != manual_attrs.end()) {
            continue;
        }
        tag_code += formatAttr(
            node.attribute("x:Class").value(),
            attr.name(),
            attr.value()
        );
    }

    pugi::xml_attribute dock = node.attribute("Dock");
    if (dock) {
        std::string dock_type = dock.value();
        std::transform(dock_type.begin(), dock_type.end(), dock_type.begin(), ::toupper);
        tag_code += std::format("{}:Dock({})\n",
            node.attribute("x:Class").value(),
            dock_type
        );
    }

    pugi::xml_attribute click = node.attribute("DoClick");
    if (click) {
        tag_code += std::format("{}.DoClick = function(sender)\n{}\nend\n",
            node.attribute("x:Class").value(),
            click.value()
        );
    }

    pugi::xml_attribute paint = node.attribute("Paint");
    if (paint) {
        tag_code += std::format("{}.Paint = function(sender,width,height)\n{}\nend\n",
            node.attribute("x:Class").value(),
            paint.value()
        );
    }

    return tag_code;
}

std::string iterate_tags(const pugi::xml_node& node) {
    std::string lua;

    if (std::string(node.name()) == "Lua") {
        lua += std::string("-- Lua block");
        lua += node.child_value();
    }
    else if (node.attribute("x:Class")) {
        lua += std::string("-- UI tag: ") + node.name() + "\n";
        lua += translate_tag(node);
    }

    for (pugi::xml_node child : node.children()) {
        lua += iterate_tags(child);
    }

    return lua;
}

int main(int argc, char* argv[])
{
    std::string source;
    for (int i = 1; i < argc; ++i) {
        if (std::string(argv[i]) == "-f" && i + 1 < argc) {
            source = argv[i + 1];
            break;
        }
    }

    if (!source.empty()) {
        auto [doc, result] = load_xml(source);

        if (result)
        {
            std::cout << "XAML [" << source << "] parsed without errors\n\n";

            std::string lua_parsed;

            for (pugi::xml_node node : doc.children()) {
                lua_parsed += iterate_tags(node);
            }
            if (enable_glob) {
                lua_parsed = glob_text + lua_parsed;
            }
            lua_parsed = mark_text + lua_parsed;

            std::filesystem::path out_p = source;
            out_p.replace_extension(".lua");
            std::ofstream out(out_p);
            if (out.is_open()) {
                out << lua_parsed << std::endl;
            }
            out.close();

            std::cout << "Saved to " << out_p << std::endl;
        }
        else
        {
            std::cout << "XAML [" << source << "] parsed with errors\n";
            std::cout << "Error description: " << result.description() << "\n";
            std::cout << "Error offset: " << result.offset << " (error at [..." << (source.c_str() + result.offset) << "]\n\n";
        }
    }
    else {
        std::cout << "Usage: ./GmXAML.exe -f <path to xaml file>" << std::endl;
    }

    return 0;
}